---
title: "Untitled"
author: "Soria Delva"
date: "2024-09-18"
output: html_document
---
This document describes how we arrived at a shortlist of species for the Horizon Scanning workshop, starting from a longlist of 7949 taxa.

# Setup
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

Load libraries.
```{r Load libraries}
library(googlesheets4)
library(googledrive)
library(readxl)
library(dplyr)
library(rgbif)
library(progress)
library(sf)
library(rnaturalearth)
library(terra)
library(data.table)
library(mapview)
library(here)
library(CoordinateCleaner)
```

```{r Create empty dataframe to hold logs}
#Create empty logs dataframe to store logs
grid_logs<-data.frame(n_taxa_longlist=as.integer(""),
                      n_taxa_no_native_plants=as.integer(""),
                      n_taxa_mapped_to_GBIF=as.integer(""),
                      n_taxa_after_remapping_corrections=as.integer(""),
                      n_taxa_after_upscaling_to_species=as.integer(""),
                      n_taxa_no_belgian_natives=as.integer(""),
                      n_taxa_downloaded_EU<-as.integer(""),
                      n_taxa_left_for_CM<-as.integer("")
)
```

#Import data

```{r Read in data}

#n=7947 unique species on the longlist
longlist <- read_excel("data/input/Species_long_list_Ana.xlsx")
grid_logs[1,1]<-length(unique(longlist$`Long name`))
longlist<-longlist%>%
  distinct(`Long name`, .keep_all=TRUE)
```


#Process data

##Remove native species based on the list of Irena

```{r Remove native species}
#Import data
Irena_plants<-read_sheet("1xnQW5rk50Unt9e2P6I3ULrEdxApZ1yj_nnzbSjgzlE0", sheet = "Data")

#Create a vector of ID's that should be removed from the longlist, these include the following;
#Archaeophytes, species native in parts of the EU (not Canary Islands), higher taxa (n=319)
Irena_plants_exclude<-Irena_plants%>%
  filter(DECISION%in% c("arch","native","excludeHigherTaxa"))%>%
  pull(ID)

#Exclude these ID's from the longlist (n=7628 left)
longlist<-longlist%>%
  filter(!ID %in% Irena_plants_exclude)

grid_logs[1,2]<-length(unique(longlist$ID))
```

##Match initial dataset with the GBIF backbone

Match data.
```{r Match scientific names with GBIF backbone}
# Match taxa names with the GBIF backbone, retrieve taxon keys from GBIF when a match is found
# Initialize progress bar
pb <- progress_bar$new(
 format = "\033[35m Processing [:bar] :current/:total (:percent) in :elapsed \033[0m",
  total = nrow(longlist),
  width = 60,
  clear = FALSE                  
)

mapped_taxa<-data.frame()
for (i in 1:nrow(longlist)){
  pb$tick()
  nubkey_row<-longlist[i,]
  data <- rgbif::name_backbone(name = nubkey_row$`Long name`)
  data$Source<-nubkey_row$Source
  data$Thematic_group<-nubkey_row$`Thematic group`
  data$ID<-nubkey_row$ID
  if(nrow(mapped_taxa)==0){
    mapped_taxa<-data
  }else{
    # check if there are missing columns in data, add them to data filled with NAs
    missing_cols_data <- setdiff(names(mapped_taxa), names(data))
    data[missing_cols_data] <- NA
    rm(missing_cols_data)
    
    # check if there are missing columns in mapped_taxa, add them to mapped_taxa filled with NAs
    missing_cols <- setdiff(names(data), names(mapped_taxa))
    mapped_taxa[missing_cols] <- NA
    rm(missing_cols)
    
    #Make sure columns are in the right order
    data <- data[, colnames(mapped_taxa)]
    
    #bind data to mapped_taxa
    mapped_taxa<-rbind(mapped_taxa,data)
  }
}

```

Export taxa that do not match with the GBIF backbone at species level.
```{r Export taxa without GBIF match}
#Filter out those that have no match with GBIF backbone
nomatch<-mapped_taxa%>%
  filter(matchType=="NONE")%>%
  select(c(ID, Thematic_group, verbatim_name,Source))

#Filter out those that have a match, but not at species level
nospeciesmatch<-mapped_taxa%>%
  filter(matchType!="NONE")%>%
  filter(is.na(speciesKey))%>%
  select(c(ID, Thematic_group, verbatim_name,Source))

#In total, n=262 species are removed 

# Write data to the new Google Sheets file
#ss0 <- gs4_create("longlist_no_match", sheets="Data")
#sheet_write(nomatch, ss= ss0, sheet="Data")
#ss1 <- gs4_create("longlist_no_species_match", sheets="Data")
#sheet_write(nospeciesmatch, ss = ss1, sheet="Data")

#Only keep taxa that are mapped to species level: n = 7368 ; n=6994
mapped_species<-mapped_taxa%>%
  filter(!is.na(speciesKey))

#Store the usageKey here as it indicates the unique taxa, still including synonyms and subspecies, some taxa appear multiple times
grid_logs[1,3]<-length(unique(mapped_species$ID))
```

```{r rematch corrected taxa}
corrected_taxa <- read_sheet("1r3DYeJ0TkMeHX50hXnPRvdm0B5KayYFqPQj749x_GLw",
                               sheet = "nomatch")
corrected_taxa<-corrected_taxa%>%
  filter(!is.na(Correction_team) & Correction_team!="?")

# Match taxa names with the GBIF backbone, retrieve taxon keys from GBIF when a match is found
# Initialize progress bar
pb_cor <- progress_bar$new(
 format = "\033[35m Processing [:bar] :current/:total (:percent) in :elapsed \033[0m",
  total = nrow(corrected_taxa),
  width = 60,
  clear = FALSE                  
)

correct_taxa<-data.frame()
for (i in 1:nrow(corrected_taxa)){
  pb_cor$tick()
  nubkey_row<-corrected_taxa[i,]
  data <- rgbif::name_backbone(name = nubkey_row$Correction_team)
  data$Source<-nubkey_row$Source
  data$Thematic_group<-nubkey_row$Thematic_group
  data$ID<-nubkey_row$ID
  if(nrow(correct_taxa)==0){
    correct_taxa<-data
  }else{
    # check if there are missing columns in data, add them to data filled with NAs
    missing_cols_data <- setdiff(names(correct_taxa), names(data))
    data[missing_cols_data] <- NA
    rm(missing_cols_data)
    
    # check if there are missing columns in mapped_taxa, add them to mapped_taxa filled with NAs
    missing_cols <- setdiff(names(data), names(correct_taxa))
    correct_taxa[missing_cols] <- NA
    rm(missing_cols)
    
    #Make sure columns are in the right order
    data <- data[, colnames(correct_taxa)]
    
    #bind data to mapped_taxa
    correct_taxa<-rbind(correct_taxa,data)
  }
}

stillnomatch<-correct_taxa%>%
  filter(is.na(speciesKey))

matchafterall<-correct_taxa%>% #134 out of 274 species have a match
  filter(!is.na(speciesKey))
#%>%#BUT 12 occur on the list of Irena, remove them!
 # filter(!ID %in% Irena_plants_exclude) #122 matched

mapped_species<-rbind(mapped_species, matchafterall)

grid_logs[1,4]<-length(unique(mapped_species$ID))
```

Get an overview of how the data look like.
```{r get taxa overview}
table(mapped_species$kingdom)
table(mapped_species$status)
table(mapped_species$rank)
```
Looks good, but there are some synonym taxa and sub taxa levels (subspecies, variety, form) present in the data, that need to be dealt with before we can proceed to the occurrence download.

##Convert synonyms to accepted taxa 

```{r Deal with synonyms}
#For all synonyms, an acceptedUsageKey of the accepted species, subspecies, or variety is provided. These records will be mapped again against the backbone, using this acceptedUsageKey.
not_accepted<-mapped_species%>%
  filter(!is.na(acceptedUsageKey))

mapped_species<-mapped_species%>%
  filter(is.na(acceptedUsageKey))

# Initialize progress bar
pb1 <- progress_bar$new(
 format = "\033[35m Processing [:bar] :current/:total (:percent) in :elapsed \033[0m",
  total = nrow(not_accepted),
  width = 60,
  clear = FALSE                  
)

synonym_fix<-data.frame()
for (i in 1:nrow(not_accepted)){
  pb1$tick()
  data_row<-not_accepted[i,]
  backbone_data<-name_usage(key=data_row$acceptedUsageKey)$data
  backbone_data$Source<-data_row$Source
  backbone_data$Thematic_group<-data_row$Thematic_group
  backbone_data$ID<-data_row$ID
  if(nrow(synonym_fix)==0){
    synonym_fix<-backbone_data
  }else{
    # check if there are missing columns in backbone_data, add them to backbone_data filled with NAs
    missing_cols_data <- setdiff(names(synonym_fix), names(backbone_data))
    backbone_data[missing_cols_data] <- NA
    rm(missing_cols_data)
    
    # check if there are missing columns in synonym_fix, add them to synonym_fix filled with NAs
    missing_cols <- setdiff(names(backbone_data), names(synonym_fix))
    synonym_fix[missing_cols] <- NA
    rm(missing_cols)
    
    #Make sure columns are in the right order
    backbone_data <- backbone_data[, colnames(synonym_fix)]
    
    #bind data to mapped_taxa
    synonym_fix<-rbind(synonym_fix,backbone_data)
  }
}

#For all taxa, nubKey equals key, except that there are 13 for which key is given (and valid) but nubKey is NA so we'll proceed with the key column
synonym_fix<-synonym_fix%>%
  select(c(key, speciesKey, scientificName, kingdom, phylum, class, order, family, genus, rank, taxonomicStatus, Source, Thematic_group, ID )) 

mapped_species_short<-mapped_species%>%
  rename(key = "usageKey",
         taxonomicStatus = "status")%>%
  select(c(colnames(synonym_fix)))

mapped_species<-rbind(mapped_species_short, synonym_fix)
rm(mapped_species_short)
```

##Do an upscale of accepted subspecies and varieties to their respective species level
```{r Deal with subspecies and varieties}
#Filter the taxa for which the key is not equal to the speciesKey
#These include subspecies, varieties, and synonyms that received the accepted taxonkey of an accepted variety or subspecies rather than an actual species
subspecies<-mapped_species%>%
  filter(key!=speciesKey)

#Remove these taxa from griis_all
mapped_species<-mapped_species%>%
  filter(key==speciesKey)

#Since the key will be the key of the accepted subspecies or variety, and the scientificName will be either the name of the accepted subspecies and variety, we'll need to map the speciesKey back to the GBIF backbone to get the scientificName (and accepted_taxon_name) for the accepted species. Just overwriting the key with the speciesKey will not be enough as the name will still be the wrong one 

# Initialize progress bar
pb2 <- progress_bar$new(
 format = "\033[35m Processing [:bar] :current/:total (:percent) in :elapsed \033[0m",
  total = nrow(subspecies),
  width = 60,
  clear = FALSE                  
)

subspecies_fix<-data.frame()
for (i in 1:nrow(subspecies)){
  pb2$tick()
  data_row<-subspecies[i,]
  backbone_data<-name_usage(key=data_row$speciesKey)$data #Map the speciesKey back to get taxonomic info
  backbone_data$Source<-data_row$Source
  backbone_data$Thematic_group<-data_row$Thematic_group
  backbone_data$ID<-data_row$ID
  if(nrow(subspecies_fix)==0){
    subspecies_fix<-backbone_data
  }else{
    # check if there are missing columns in backbone_data, add them to backbone_data filled with NAs
    missing_cols_data <- setdiff(names(subspecies_fix), names(backbone_data))
    backbone_data[missing_cols_data] <- NA
    rm(missing_cols_data)
    
    # check if there are missing columns in subspecies_fix, add them to subspecies_fix filled with NAs
    missing_cols <- setdiff(names(backbone_data), names(subspecies_fix))
    subspecies_fix[missing_cols] <- NA
    rm(missing_cols)
    
    #Make sure columns are in the right order
    backbone_data <- backbone_data[, colnames(subspecies_fix)]
    
    #bind data to mapped_taxa
    subspecies_fix<-rbind(subspecies_fix,backbone_data)
  }
}
#all values of key are equal to nubKey
subspecies_fix<-subspecies_fix%>%
  select(c(colnames(mapped_species)))

#Bind the two dataframes back together
mapped_species<-rbind(mapped_species, subspecies_fix) #7804

#By converting synonyms, subspecies, and varieties back to the accepted species, there is a chance that the same species will occur multiple times in the list, we need to collapse first
mapped_species<-mapped_species%>%
  distinct(key, .keep_all = TRUE)%>%
  select(-c(speciesKey, taxonomicStatus,rank)) #Remove columns that we don't need anymore, all speciesKeys are equal to key, taxonomicStatus is accepted or doubtful (no more synonyms), and rank is species

grid_logs[1,5]<-length(unique(mapped_species$ID))
```

The processed longlist contains x species that can be used for downloading. From the initial 7947 records, x could not be matched with the GBIF backbone at species level. After converting synonyms to the accepted taxon and upscaling varieties and subspecies to their respective species level, another x turned out to be duplicates of an accepted species that was already present on the list.

##Remove species native to Belgium

Ideally we should remove all species that are native to one or multiple member states. However, as such a list is not available this won't be possible. As an alternative, we will remove all species that are native to Belgium, as indicated in the [list of species observed in Belgium from waarnemingen.be](https://www.gbif.org/dataset/2c38cf8a-f981-4dfb-bc9d-dd2b6fc792ed)

Import taxon information

```{r Create a list with native species in Belgium}
#Load data from the list of species observed in Belgium
taxon <- fread("./data/input/gbif_waarnemingen_data/taxon.txt")
distribution <- fread("./data/input/gbif_waarnemingen_data/distribution.txt")

#Get the id's of the native taxa
native_id<-distribution%>%
  filter(establishmentMeans=="native")%>%
  distinct(id)%>%
  pull(id)

#Create a dataset with native taxa and one with invasive taxa 
native_taxa<-taxon%>%
  filter(id %in% c(native_id))
invasive_taxa<-taxon%>%
  filter(!id %in% c(native_id))

# Match taxa names with the GBIF backbone, retrieve taxon keys from GBIF when a match is found
# Initialize progress bar
pb_natives <- progress_bar$new(
  format = "\033[35m Processing [:bar] :current/:total (:percent) in :elapsed \033[0m",
  total = nrow(native_taxa),
  width = 60,
  clear = FALSE                  
)

mapped_natives<-data.frame()
for (i in 1:nrow(native_taxa)){
  pb_natives$tick()
  nubkey_row<-native_taxa[i,]
  data <- rgbif::name_backbone(name = nubkey_row$scientificName)
  if(nrow(mapped_natives)==0){
    mapped_natives<-data
  }else{
    # check if there are missing columns in data, add them to data filled with NAs
    missing_cols_data <- setdiff(names(mapped_natives), names(data))
    data[missing_cols_data] <- NA
    rm(missing_cols_data)
    
    # check if there are missing columns in mapped_natives, add them to mapped_natives filled with NAs
    missing_cols <- setdiff(names(data), names(mapped_natives))
    mapped_natives[missing_cols] <- NA
    rm(missing_cols)
    
    #Make sure columns are in the right order
    data <- data[, colnames(mapped_natives)]
    
    #bind data to mapped_natives
    mapped_natives<-rbind(mapped_natives,data)
  }
}

#99 species do not match with the GBIF backbone at species level
nonativematch<-mapped_natives%>%
  filter(is.na(speciesKey))

#Save these data to a google sheets file
#nonativematchsave<-nonativematch%>%
 # select(c(verbatim_name, scientificName,rank, confidence, matchType))
#ss1 <- gs4_create("No_match_Belgian_natives", sheets="Data")
#sheet_write(nonativematchsave, ss = ss1, sheet="Data")

#16106 of 16205 native species remain, they include only species (no varieties or subspecies) but also synonyms
#The usageKey is the same as the speciesKey except for the synonyms. Here, the acceptedUsageKey mostly equals the speciesKey but not always (in cases where the accepted taxon is a subspecies or variety)
#For those taxa for which the acceptedUsageKey (key of accepted taxon) equals the speciesKey (meaning that the accepted taxon is a species), we can just use the speciesKey for matching with the longlist. For those for which the acceptedUsageKey does not match the speciesKey, we can also use the speciesKey as the acceptedUsageKey will be the key for the accepted subspecies or variety and the speciesKey will be the key of the accepted higher level species

mapped_natives_final<-mapped_natives %>%
  dplyr::filter(rank %in% c("SPECIES", "SUBSPECIES", "VARIETY"),
                !is.na(usageKey))%>%
  distinct(speciesKey)

#Since we are not interested in the scientific name (only in the taxonkey), we don't need to do the match again for synonyms (it is okay if scientific name is not overwritten by the name of the accepted species)

```


Check which species match with the longlist species

```{r Flag native Belgian species on longlist}
#329 native Belgian species are flagged on the longlist
sum(mapped_natives_final$speciesKey %in% mapped_species$key)

#Store them in a separate list to be checked by an expert
Belgium_natives<-mapped_species%>%
  filter(key %in% c(mapped_natives_final$speciesKey))

Belgium_natives<-longlist%>%
  select(c(ID, `Long name`))%>%
  inner_join(Belgium_natives, by="ID")%>%
  select(c(ID,key,`Long name`, scientificName, kingdom, class, family, Source, Thematic_group ))

#Export to a google sheets document
#ss1 <- gs4_create("Belgian_natives", sheets="Data")
#sheet_write(Belgium_natives, ss = ss1, sheet="Data")

#Exclude these species from the final longlist that will be used in the download: 6740
mapped_species_final<-mapped_species%>%
  filter(!ID %in% Belgium_natives$ID)


grid_logs[1,6]<-length(unique(mapped_species_final$ID))
```

```{r get data overview}
table(mapped_species$kingdom)
table(mapped_species$class)
```

```{r Clean up}
#Remove objects we don't need anymore
rm(backbone_data, Belgium_natives, correct_taxa, corrected_taxa, data, data_row, distribution, invasive_taxa, mapped_natives, mapped_natives_final, mapped_species, mapped_taxa, matchafterall, native_taxa, nomatch, nonativematch, nospeciesmatch, not_accepted, nubkey_row, stillnomatch, subspecies, subspecies_fix, synonym_fix, taxon, pb,pb_cor, pb_natives, pb1, pb2)

```


#Download occurrence data 

##Prepare shapefile that can be added to occ_download

Prepare shapefile

```{r prepare shapefile}
#Create vector of EU member states
memberstates<-read.csv2(here("./data/input/GRIIS_checklists.csv"))%>%
  pull(EU_state)

#Get shapefile of EEZ of EU member states
EEZ<-st_read("./data/spatial/EEZ/EEZ_land_v2_201410.shp")%>%
  filter(Country%in% c(memberstates, "Czech Republic"))

#Explore
mapview::mapview(EEZ)

#Erase canary islands and Azores using a custom shape file
mask_islands<-st_read("./data/spatial/EU_mask.shp") 
EEZ<-EEZ%>%
  st_difference(mask_islands)

mapview(EEZ)
```

```{r Put shapefile in right format for download}
EEZ$group<-"EU"
EEZ_wkt<- EEZ%>% 
  group_by(group) %>% 
  summarise()%>% #Merge multipolygons of EU states into one multipolygon 
  #sf::st_simplify(dTolerance=10) %>% #simpligy the polygon because there were too many points for rgbif
  st_make_valid()%>%
  sf::st_geometry() %>% 
  sf::st_as_text()%>%  
  wk::wkt() %>% 
  wk::wk_orient()#Due to changes in GBIF’s polygon interpretation, you might get an error when using polygons wound in the “wrong direction” (clockwise, i.e., default of sf). Reorient the polygon using the wk package

```

##Download occurrences inside EEZ of European Member States

```{r GBIF download}
#Extract taxonkeys as vector (length 7041, 6740. 6751 in gbif download)
taxonkeys<-mapped_species_final%>%
  pull(key)

#Indicate basis of record for download
basis_of_record <- c(
  "OBSERVATION", 
  "HUMAN_OBSERVATION",
  "MATERIAL_SAMPLE", 
  "LITERATURE", 
  "PRESERVED_SPECIMEN", 
  "UNKNOWN", 
  "MACHINE_OBSERVATION")


# Identification_verification_status to discard
identificationverificationstatus_to_discard<- c(
  "unverified",
  "unvalidated",
  "not validated",
  "under validation",
  "not able to validate",
  "control could not be conclusive due to insufficient knowledge",
  "Control could not be conclusive due to insufficient knowledge",
  "0",
  "uncertain",
  "unconfirmed",
  "Douteux",
  "Invalide",
  "Non r\u00E9alisable",
  "verification needed" ,
  "Probable",
  "unconfirmed - not reviewed",
  "validation requested")

#Download occurrences for each taxonkey (n = 6751) inside EEZ of member states (approx. 7h)
system.time({
  gbif_download_key <- rgbif::occ_download(
    pred_in("taxonKey", taxonkeys),
    pred("hasGeospatialIssue", FALSE), #Remove default geospatial issues
    pred("hasCoordinate", TRUE), # Keep only records with coordinates
    pred("occurrenceStatus", "PRESENT"), #Keep only presences
    pred_within(EEZ_wkt), #keep only records within EEZ of member states
    pred_in("basisOfRecord", basis_of_record),#basisOfRecord has to match aforementioned categories
    pred_or(
      pred_lt("coordinateUncertaintyInMeters",50000),
      pred_isnull("coordinateUncertaintyInMeters")),
    pred_gte("year", 1980), #Year has to be 1980 or higher
    pred_lte("year", year(Sys.Date())) #Year has to be current year or lower
  )
  
  #Follow the status of the download (downloadkey: 0025284-240906103802322)
  occ_download_wait(gbif_download_key)
}) 

#Get DOI of download
print(gbif_citation(occ_download_meta(gbif_download_key))$download)

#--------------Retrieve downloaded records-------------
#edit_r_environ()
#Add =13Gb to the renviron file, save, and restart R session 

gbif_download_key<-"0033551-240906103802322" #Downloaded september 28

#The download file is too large to read into R as a whole, only import data for selected columns
occ_download_get(gbif_download_key,overwrite = TRUE, path=tempdir())%>%
  unzip( exdir = tempdir())

#Records for 3535 (out of 6740) species are downloaded (the others don't have records in Europe, at least not for our selection criteria)
species_records<-fread(file.path(tempdir(), paste0("occurrence.txt")), 
                       select=c("speciesKey","scientificName","year","decimalLatitude", "decimalLongitude", "coordinateUncertaintyInMeters", "kingdom","phylum","class","order", "family", "genus", "taxonKey","identificationVerificationStatus"))

#Check how many speciesKeys are present in download
grid_logs[1,7]<-length(unique(species_records$speciesKey)) #3243 FINAL LIST

```

##Clean occurrence data

```{r Data cleaning}
# Only keep coordinates that are not flagged as potentially problematic
species_records<- species_records%>%
  filter(!identificationVerificationStatus %in% identificationverificationstatus_to_discard)%>%
    cc_cen(buffer=50) %>% # remove points within a buffer of 50m of country centroids
    cc_cap(buffer=50) %>% # remove capitals centroids (buffer 50m)
    cc_inst(buffer=50) %>% # remove zoo and herbaria
    cc_gbif(buffer=50)%>%
    cc_zero()
  
length(unique(species_records$speciesKey))
 #3166, 77 removed by coordinate cleaner


```

##Prepare European raster 

Read 50 x 50 km EEA raster grid

```{r Convert 50x50 EEA grid to raster}
#Read data
eu_grid <- read_sf("./data/spatial/EEA_50km_grid_v2024.gpkg")

# Convert geometry to right format
eu_grid<-st_cast(eu_grid, "GEOMETRYCOLLECTION") %>% st_collection_extract("POLYGON")

#----------------------Convert the grid to a raster-----------------------
#Turn grid into spatVector
eu_grid_vect <- vect(eu_grid)

# Define the resolution of the raster (50000x50000 meters)
resolution <- 50000  

# Create an empty raster with the extent, resolution, and crs
raster_template <- rast(ext(eu_grid_vect), 
                        resolution = resolution, 
                        crs = crs(eu_grid_vect))

# Convert polygons to a raster and choose column to rasterize (cellcode)
EU_raster <- rasterize(eu_grid_vect, raster_template, field = "cellcode")

# Plot the rasterized data
mapview(EU_raster)

```


Mask rastergrid to extent of EU member states and their respective EEZ 

```{r Mask EEA raster grid and convert to shapefile}
#Transform to same crs as 50x50rastergrid
EEZ<-EEZ%>%
  st_transform(., crs=st_crs(eu_grid))

#Crop raster grid to extent of EEZ shape
EEZ_ext<-terra::ext(EEZ) 

#Convert EEZ to a SpatVector that can be used for masking
EEZ_vector <- vect(EEZ) 

#Crop EU_raster to extent of EEZ
EU_raster_crop <- terra::crop(EU_raster, EEZ_ext)

# Rasterize the EEZ SpatVector to the extent and resolution of the cropped EU raster
#All raster cells that touch the EEZ shape are included, country is assigned based on in which country tha majority of the cell's surface area falls
eu_50raster <- terra::rasterize(EEZ_vector, EU_raster_crop, field = "Country", touches=TRUE)

#Visualize raster
mapview(eu_50raster)

#Remove objects 
rm(EEZ,EEZ_ext, EEZ_vector, EU_raster, eu_grid, EU_raster_crop, mask_islands, raster_template, eu_grid_vect)

```

##Count for each taxon how many grids are occupied in total and per country 

```{r}
#Convert coordinates to crs 3035
species_records<-st_as_sf(species_records, coords=c("decimalLongitude", "decimalLatitude"), crs=4326, remove=FALSE)%>%
  st_transform(crs=st_crs(3035))%>%
  st_coordinates()%>%
  cbind(., species_records)

# Get the cellnumber for each observation
species_records$grid_cell <- cellFromXY(eu_50raster, species_records[,c("X","Y")]) 

#Assign country codes based on the grid cell
species_records$country <- terra::extract(eu_50raster, species_records[,c("X", "Y")])[, "Country"]  

# Remove observations in NA grid cells (i.e., outside the study area) and NA countries (not in an EU member state) (should be zero since we already filtered on that in download)
#Filter to only include grid cells where a species has been observed in more than one year
#2247 species
species_records <- species_records%>%
  filter(!is.na(grid_cell), 
       !is.na(country))%>%
  group_by(speciesKey, grid_cell) %>%
  filter(n_distinct(year) > 1)%>%# Keeps only grid cells with multiple years of observations 
  ungroup()


#Export the species for which no records are downloaded or for which all records were removed by coordinate cleaner or previous filtering steps (4504 FINAL LIST)
taxa_not_included<-mapped_species_final%>%
  filter(!key %in% c(species_records$speciesKey))%>% 
  mutate(total_grid_cells=0,
         grid_cells_per_country=0,
         country=NA_character_,
         grid_cell= NA
        )


# Count the number of unique grid cells per species overall (n=2247 species, of which 375 occupy 1 grid cell and 198 occupy two grid cells: 573 of 2247 are kept )
total_cell_count <- species_records%>%
  group_by(speciesKey) %>%
  summarise(total_grid_cells = n_distinct(grid_cell))%>%
  ungroup()%>%
  left_join(., mapped_species_final[,c("key", "scientificName", "kingdom", "phylum", "class", "order", "family", "genus", "Source", "Thematic_group", "ID")], by = c("speciesKey" = "key"))

#Together with the 4504 species that were not included: 5077 species (here 6751, same as taxonkeys length for download, because still including those with more than two grid cells occupied)
total_cell_count<- taxa_not_included %>%
   rename(speciesKey = "key")%>%
  select(c(colnames(total_cell_count)))%>%
  rbind(.,total_cell_count)
 

# Count the number of unique grid cells per species per country (n=  15635 DWCA, 24 264 with at least 1 observation,15332 with at least 2)
country_cell_count<- species_records%>%
  group_by(speciesKey, country) %>%
  summarise(grid_cells_per_country = n_distinct(grid_cell))%>%
  ungroup()%>%
  left_join(., mapped_species_final[,c("key", "scientificName", "kingdom", "phylum", "class", "order", "family", "genus", "Source", "Thematic_group", "ID")], by = c("speciesKey" = "key"))
  
country_cell_count<- taxa_not_included %>%
   rename(speciesKey = "key")%>%
  select(c(colnames(country_cell_count)))%>%
  rbind(.,country_cell_count)

#Create a dataframe with total grid cells and column that indicates how many in which country 
total_gridcells <- country_cell_count %>%
  # Group by specieskey
  group_by(speciesKey) %>%
  # Summarize to get the total grid cells per specieskey
  summarize(
    total_grid_cells = sum(grid_cells_per_country, na.rm = TRUE),
    # Create the text summary for country and grid cell counts, handling NA
    n_gridcells_country = if (all(is.na(country))) {
    "0"# Return NA if all country values are NA
    } else {
      paste(
        paste(country[!is.na(country)], "(", grid_cells_per_country[!is.na(country)], ")", sep = ""),
        collapse = ", "
      )
    }
  ) %>%
ungroup()%>%
  left_join(., mapped_species_final[,c("key", "scientificName", "kingdom", "phylum", "class", "order", "family", "genus", "Source", "Thematic_group", "ID")], by = c("speciesKey" = "key"))

#Remove native plants from list Irena that slipped through via the corrected google sheets
total_gridcells<-filter(total_gridcells, !ID %in% Irena_plants_exclude)

#------------------------Fix thematic groups-------------------------
#Read in list of Ana that has corrected thematic groups
list_ana<-read_sheet("1Wo-SPMJaa8M3R3PnyOkPbVA5ethnWYLxNVxNyQ4_w-g", sheet="Data")

# Perform a left join to bring in the thematic group values from dataset2
total_gridcells <- total_gridcells%>%
  left_join(list_ana %>% select(ID, Thematic_group), by = "ID", suffix = c("_orig", "_new")) %>%
  # Use mutate to replace the original Thematic_group with the new one if it exists
  mutate(
    Thematic_group = ifelse(!is.na(Thematic_group_new), Thematic_group_new, Thematic_group_orig)
  ) %>%
  # Remove the extra columns used for the join
  select(-Thematic_group_orig, -Thematic_group_new)

#ss0<-gs4_create("Total_gridcells", sheets="Data")
#sheet_write(total_gridcells, sheet="Data", ss=ss0)

```


```{r Visualize distribution for up to 20 occupied grid cells}
total_cell_count%>%
filter( total_grid_cells<21 & total_grid_cells>0)%>%
ggplot( aes(total_grid_cells)) +
  geom_histogram(binwidth=1, color="black", fill="green") +
  stat_bin(binwidth=1, geom='text', color='black', aes(label=after_stat(count)),
           position=position_stack(vjust = 0.5))+
  geom_vline(xintercept=2.5, color="red", size=1)+
  xlab("Number of grid cells occupied") + ylab("Number of species")+
  scale_x_continuous(breaks=1:20)+
  theme_bw()

```

##Prepare dataset for climate matching

We will keep the species of the download that occupy 0-2 grid cells in EU member states and their EEZ

```{r Prepare climate matching data}
#n=5077 (see before; still includes one of natives of Irena, but this was filtered out after CM)
climate_matching<-total_cell_count%>%
  filter(total_grid_cells<3)

#Filter out species that are indicated as marine:505
marine<-filter(climate_matching, Thematic_group=="Marine")
length(unique(marine$ID))

#Remove marine species from climate matching dataset: n=4572 in total for climate matching
climate_matching<-filter(climate_matching, Thematic_group!="Marine")
grid_logs[1,8]<-length(unique(climate_matching$ID))

#Remove all files except for climate_matching and marine
rm(list = setdiff(ls(), c("marine", "climate_matching")))
gc()
```


Create a dataset for all species that occupy 5 grid cells or less in the EU, with the cellcode of the gridcells that they occupy indicated. This will then be used to generate maps of each species.
```{r Create dataset to visualize gridcells on EU maps}
#Keep species that occupy 5 grid cells or less
ids_tokeep<-total_gridcells%>%
  filter(total_grid_cells<6)%>%
  pull(speciesKey)

#Per species, keep only distinct grid cells
maps_data<-species_records%>%
  filter(speciesKey%in%ids_tokeep)%>%
  group_by(speciesKey,country)%>%
 distinct(grid_cell)

#Add taxa without any grid cells in the EU, as well as taxonomic info and the number of grid cells a species occupied
maps_data<- taxa_not_included %>%
   rename(speciesKey = "key")%>%
  select(c(colnames(maps_data)))%>%
  rbind(.,maps_data)%>%
  left_join(., mapped_species_final[,c("key", "scientificName", "kingdom", "phylum", "class", "order", "family", "genus", "Source", "Thematic_group", "ID")], by = c("speciesKey" = "key"))%>%
  left_join(., total_gridcells[,c("total_grid_cells", "ID","n_gridcells_country")], by="ID")

#----------Add spatial information of every grid cell----------
cellcoords<- xyFromCell(eu_50raster, maps_data$grid_cell)
maps_data<-cbind(maps_data, cellcoords)

#Export data (5362 unique IDs, 286 with 3-5 grid cells + 5076 with max 2 grid cells)
ss0<-gs4_create("maps_data_final", sheets="Data")
write_sheet(maps_data, ss=ss0, sheet="Data")
```


---
title: "create_list_aliens"
author: "Soria Delva"
date: "2024-09-13"
output: html_document
---

This script is constructed to assess how many times a given alien species is included on the GRIIS checklist of EU countries (maximum is 27 times)

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


Load libraries:
```{r load_libraries, echo=FALSE}
library(dplyr)
library(readr)
library(here) 
library(rgbif)
library(progress)
library(future.apply)
```


##Import data
Get taxa from the Global Register of Introduced and Invasive Species (GRIIS) checklist for each EU member state

```{r make datasetkey list}
griis<-read.csv2(here("./data/input/GRIIS_checklists.csv"))
griis_list<-as.list(griis$GRIIS_checklist)
```

```{r create dataset with all griis data of eu member states}

# Initialize progress bar
pb <- progress_bar$new(
 format = "\033[35m Processing [:bar] :current/:total (:percent) in :elapsed \033[0m",
  total = nrow(griis),
  width = 60,
  clear = FALSE                   # Keep the bar visible after completion
)

  griis_taxa<-purrr::map(seq_along(griis$GRIIS_checklist), function(x) {
    pb$tick()
    all_data<-name_usage(datasetKey = griis[x,2], limit=100000)
    country<-griis[x,1]
    taxon_data<-all_data$data%>%
      filter(origin=="SOURCE", #CHECK THIS!
             rank %in% c("SPECIES", "SUBSPECIES", "VARIETY",NA))%>% 
      select(c(nubKey,datasetKey,kingdom, phylum, order, family, scientificName,rank,taxonomicStatus))%>%
      mutate(griis_country = country)
    return(taxon_data)
  }
  )
  
griis_taxa<- do.call(rbind, griis_taxa)  # Merge the different griis taxa datasets, 32523

#Adjust weird spelling
griis_taxa <- griis_taxa %>%
  mutate(scientificName = gsub("Ã—", "×", scientificName))%>%
  mutate(scientificName = gsub("Ã©", "é", scientificName))%>%
  mutate(scientificName = gsub("í«", "ë", scientificName))%>%
  mutate(scientificName = gsub("Ã¸", "ø", scientificName))%>%
  mutate(scientificName = gsub("Ã¼", "ü", scientificName))%>%
  mutate(scientificName = gsub("Ã¶", "ö", scientificName))%>%
  mutate(scientificName = gsub("Á¨", "è", scientificName))%>%
  mutate(scientificName = gsub("Á³", "ó", scientificName))%>%
  mutate(scientificName = gsub("Ä ", "č", scientificName))%>%
  mutate(scientificName = gsub("Á¡", "á", scientificName))%>%
  mutate(scientificName = gsub("Á", "í", scientificName))%>%
  mutate(scientificName = gsub("Á", "í", scientificName))%>%
  mutate(scientificName = gsub("í ", "Á", scientificName))%>%
  mutate(scientificName = gsub("Ã", "Á", scientificName))%>%
  mutate(scientificName = case_when(scientificName == "Entyloma gaillardianum VÁ¡nky"~
                                      "Entyloma gaillardianum Vánky",
                                    scientificName == "Elodea can+D625:M626adensis Michx."~
                                      "Elodea canadensis Michx.",
                                    scientificName=="Metha spicata x suaveolens"~
                                      "Mentha spicata x suaveolens",
                                      TRUE ~ scientificName))
```

##Add rationale to deal with missing nubKeys 
```{r deal with missing nubkeys}
#NOTE: 1570 nubKeys are NA, for these we need to extract the nubKey based on scientificName. 
#Extract all taxa that do not have an associated nubKey
nubkey_na<-griis_taxa%>%
  filter(is.na(nubKey)) %>%
  select(scientificName, griis_country, datasetKey)

#Remove these taxa from the griis_taxa dataset
griis_taxa<-griis_taxa%>%
  filter(!is.na(nubKey))

# Match taxa names with the GBIF backbone, retrieve taxon keys from GBIF when a match is found
# Initialize progress bar
pb2 <- progress_bar$new(
 format = "\033[35m Processing [:bar] :current/:total (:percent) in :elapsed \033[0m",
  total = nrow(nubkey_na),
  width = 60,
  clear = FALSE                  
)

mapped_taxa<-data.frame()
for (i in 1:nrow(nubkey_na)){
  pb2$tick()
  nubkey_row<-nubkey_na[i,]
  data <- rgbif::name_backbone(name = nubkey_row$scientificName)
  data$griis_country<-nubkey_row$griis_country
  data$datasetKey<-nubkey_row$datasetKey
  if(nrow(mapped_taxa)==0){
    mapped_taxa<-data
  }else{
    # check if there are missing columns in data, add them to data filled with NAs
    missing_cols_data <- setdiff(names(mapped_taxa), names(data))
    data[missing_cols_data] <- NA
    rm(missing_cols_data)
    
    # check if there are missing columns in mapped_taxa, add them to mapped_taxa filled with NAs
    missing_cols <- setdiff(names(data), names(mapped_taxa))
    mapped_taxa[missing_cols] <- NA
    rm(missing_cols)
    
    #Make sure columns are in the right order
    data <- data[, colnames(mapped_taxa)]
    
    #bind data to mapped_taxa
    mapped_taxa<-rbind(mapped_taxa,data)
  }
}

nomatch<-mapped_taxa%>%
  filter(matchType %in% c("NONE")) #n=48

#Filter on rank and select same columns as in griis_taxa
mapped_taxa<-mapped_taxa %>%
  dplyr::filter(rank %in% c("SPECIES", "SUBSPECIES", "VARIETY"),
                !is.na(usageKey))%>%
   select(c(usageKey, datasetKey,kingdom, phylum, order, family, scientificName,rank,status, griis_country, class))%>%
  rename(nubKey="usageKey",
         taxonomicStatus="status") #Lost 186 here

#Reorder columns so they match the order in griis_taxa
mapped_taxa<-mapped_taxa[,colnames(griis_taxa)]

#Combine datasets
griis_taxa<-rbind(griis_taxa, mapped_taxa)

#Remove objects 
remove(mapped_taxa, nubkey_na, nubkey_row)


```

##Add rationale to deal with synonyms
```{r deal with synonyms}
#Get nubkeys, match them with the gbif backbone, and compare acceptedKey with key

#For all synonyms, an acceptedKey and accepted scientific name (column 'accepted') are provided. These will be stored under the field accepted_taxa_key and accepted_taxon_name, respectively. In case the taxon is not a synonym, these are not provided and the values in columns 'key' and 'scientificName' are stored in accepted_taxa_key and accepted_taxon_name. It is necessary to run this part for all rows, and not only the synonyms.

# Initialize progress bar
pb3 <- progress_bar$new(
 format = "\033[35m Processing [:bar] :current/:total (:percent) in :elapsed \033[0m",
  total = nrow(griis_taxa),
  width = 60,
  clear = FALSE                  
)

synonym_fix<-data.frame()
for (i in 1:nrow(griis_taxa)){
  pb3$tick()
  data_row<-griis_taxa[i,]
  backbone_data<-name_usage(key=data_row$nubKey)$data
  backbone_data$griis_country<-data_row$griis_country
  backbone_data$datasetKey<-data_row$datasetKey
  if(nrow(synonym_fix)==0){
    synonym_fix<-backbone_data
  }else{
    # check if there are missing columns in backbone_data, add them to backbone_data filled with NAs
    missing_cols_data <- setdiff(names(synonym_fix), names(backbone_data))
    backbone_data[missing_cols_data] <- NA
    rm(missing_cols_data)
    
    # check if there are missing columns in synonym_fix, add them to synonym_fix filled with NAs
    missing_cols <- setdiff(names(backbone_data), names(synonym_fix))
    synonym_fix[missing_cols] <- NA
    rm(missing_cols)
    
    #Make sure columns are in the right order
    backbone_data <- backbone_data[, colnames(synonym_fix)]
    
    #bind data to mapped_taxa
    synonym_fix<-rbind(synonym_fix,backbone_data)
  }
  #if (i %% 100 == 0){
 # print(sprintf("Processed %d of %d", i, nrow(griis_taxa)))
  #}
}

#in this dataset key and nubKey are all equal
griis_all<-synonym_fix%>%
  mutate(accepted_taxa_key = dplyr::coalesce(acceptedKey, key),
         accepted_taxon_name=dplyr::coalesce(accepted,scientificName))%>%
  filter(rank%in%c("SPECIES", "SUBSPECIES", "VARIETY"))%>%
  select(c(accepted_taxa_key, accepted_taxon_name,speciesKey, datasetKey,kingdom, phylum, order, family, scientificName,rank,taxonomicStatus, griis_country, class))%>%
  group_by(griis_country, accepted_taxa_key) %>%
  filter(row_number() == 1) %>%  # Keeps only the first occurrence of each `accepted_taxa_key` within each country
  ungroup()

```

##Add rationale to deal with subspecies and varieties
```{r deal with subspecies, varieties,...}
#Filter the taxa for which the accepted_taxa_key is not the speciesKey
#These include subspecies, varieties, and synonyms that received the accepted taxonkey of an accepted variety or subspecies rather than an actual species

#Select taxa for which accepted_taxa_key does not equal the speciesKey
subspecies<-griis_all%>%
  filter(accepted_taxa_key!=speciesKey)

#Remove these taxa from griis_all
griis_all<-griis_all%>%
  filter(accepted_taxa_key==speciesKey)

#Since the accepted_taxa_key will be the key of the accepted subspecies or variety, and the scientificName will be either the name of the accepted subspecies and variety, or in case of synonyms, of the original (unaccepted) synonym scientificName, we'll need to map the speciesKey back to the GBIF backbone to get the scientificName (and accepted_taxon_name) for the accepted species. Just overwriting the accepted_taxa_key with the speciesKey will not be enough as the name will still be the wrong one (see this paragraph)

# Initialize progress bar
pb4 <- progress_bar$new(
 format = "\033[35m Processing [:bar] :current/:total (:percent) in :elapsed \033[0m",
  total = nrow(subspecies),
  width = 60,
  clear = FALSE                  
)

subspecies_fix<-data.frame()
for (i in 1:nrow(subspecies)){
  pb4$tick()
  data_row<-subspecies[i,]
  backbone_data<-name_usage(key=data_row$speciesKey)$data #Map the speciesKey back to get taxonomic info
  backbone_data$griis_country<-data_row$griis_country
  backbone_data$datasetKey<-data_row$datasetKey
  if(nrow(subspecies_fix)==0){
    subspecies_fix<-backbone_data
  }else{
    # check if there are missing columns in backbone_data, add them to backbone_data filled with NAs
    missing_cols_data <- setdiff(names(subspecies_fix), names(backbone_data))
    backbone_data[missing_cols_data] <- NA
    rm(missing_cols_data)
    
    # check if there are missing columns in subspecies_fix, add them to subspecies_fix filled with NAs
    missing_cols <- setdiff(names(backbone_data), names(subspecies_fix))
    subspecies_fix[missing_cols] <- NA
    rm(missing_cols)
    
    #Make sure columns are in the right order
    backbone_data <- backbone_data[, colnames(subspecies_fix)]
    
    #bind data to mapped_taxa
    subspecies_fix<-rbind(subspecies_fix,backbone_data)
  }
}

subspecies_fix<-subspecies_fix%>%
  mutate(accepted_taxon_name = scientificName,
         accepted_taxa_key= key)%>% #overwrite with key instead of nubKey as 5 nubKeys are NA while key does have the right value
  select(c(colnames(griis_all)))

#Bind the two dataframes back together
griis_all<-rbind(griis_all, subspecies_fix) #31463

#By converting synonyms, subspecies, and varieties back to the accepted species, there is a chance that for the same country the same species will be multiple times in the list, we need to collapse that first before we do our count
griis_all<-griis_all%>%
  distinct(accepted_taxa_key, accepted_taxon_name, griis_country, .keep_all = TRUE)%>%
  select(-c(speciesKey, scientificName,taxonomicStatus,rank)) #Remove columns that we don't need anymore, all speciesKeys are equal to accepted_taxa_key and the only scientificName that are not equal to accepted_taxon_name are those of the synonyms for which accepted_taxon_name got replaced by the name of the accepted species 

```

##Count in how many countries an alien is included on the GRIIS checklist
```{r count aliens on GRIIS checklists}
#n=10715 (ervoor 11300 soorten)
griis_overview<-griis_all%>%
  filter(kingdom%in%c("Animalia","Plantae", "Chromista"))%>%
  group_by(accepted_taxa_key, accepted_taxon_name,kingdom,order,class)%>%
  summarize(n_checklists = n(),
            countries = paste(unique(griis_country), collapse = ", ")) %>%
  ungroup() 

```

```{r make graphical overviews of data}
hist(griis_overview$n_checklists)
table(griis_overview$n_checklists)
```


